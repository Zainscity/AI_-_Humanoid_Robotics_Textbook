{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","href":"/docs/","label":"Introduction: Building the Future of Physical AI","docId":"intro","unlisted":false},{"type":"category","label":"Foundations","items":[{"type":"link","href":"/docs/foundations/intro","label":"Part I: Foundations of Physical AI & Embodied Intelligence","docId":"foundations/intro","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Module 1: ROS 2","items":[{"type":"link","href":"/docs/module1/ros2-nodes","label":"Chapter 1: Understanding ROS 2 Nodes","docId":"module1/ros2-nodes","unlisted":false},{"type":"link","href":"/docs/module1/ros2-topics","label":"Chapter 2: Communicating with ROS 2 Topics","docId":"module1/ros2-topics","unlisted":false},{"type":"link","href":"/docs/module1/ros2-services","label":"Chapter 3: Using ROS 2 Services for Request/Response","docId":"module1/ros2-services","unlisted":false},{"type":"link","href":"/docs/module1/ros2-actions","label":"Chapter 4: Handling Long-Running Tasks with ROS 2 Actions","docId":"module1/ros2-actions","unlisted":false},{"type":"link","href":"/docs/module1/rclpy","label":"Chapter 5: A Closer Look at rclpy","docId":"module1/rclpy","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Module 2: Simulation","items":[{"type":"link","href":"/docs/module2/urdf-modeling","label":"Chapter 6: Modeling a Humanoid with URDF","docId":"module2/urdf-modeling","unlisted":false},{"type":"link","href":"/docs/module2/gazebo-simulation","label":"Chapter 7: Simulating the World with Gazebo","docId":"module2/gazebo-simulation","unlisted":false},{"type":"link","href":"/docs/module2/unity-rendering","label":"Chapter 8: High-Fidelity Simulation with Unity","docId":"module2/unity-rendering","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Module 3: NVIDIA Isaac","items":[{"type":"link","href":"/docs/module3/isaac-sim-basics","label":"Chapter 9: NVIDIA Isaac Sim for Advanced Simulation","docId":"module3/isaac-sim-basics","unlisted":false},{"type":"link","href":"/docs/module3/isaac-ros","label":"Chapter 10: Accelerating Robotics with Isaac ROS","docId":"module3/isaac-ros","unlisted":false},{"type":"link","href":"/docs/module3/nav2-biped","label":"Chapter 11: Bipedal Navigation with Nav2","docId":"module3/nav2-biped","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Module 4: VLA","items":[{"type":"link","href":"/docs/module4/whisper","label":"Chapter 12: Voice Control with OpenAI Whisper","docId":"module4/whisper","unlisted":false},{"type":"link","href":"/docs/module4/llm-planning","label":"Chapter 13: Cognitive Planning with Large Language Models","docId":"module4/llm-planning","unlisted":false},{"type":"link","href":"/docs/module4/vla-pipelines","label":"Chapter 14: Building Vision-Language-Action (VLA) Pipelines","docId":"module4/vla-pipelines","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Capstone Project","items":[{"type":"link","href":"/docs/capstone/main","label":"Part VI: Capstone Project - The Autonomous Humanoid Assistant","docId":"capstone/main","unlisted":false}],"collapsed":true,"collapsible":true},{"type":"category","label":"Appendices","items":[{"type":"link","href":"/docs/appendices/hardware-guide","label":"Appendix A: Hardware Guide","docId":"appendices/hardware-guide","unlisted":false},{"type":"link","href":"/docs/appendices/weekly-roadmap","label":"Appendix B: 13-Week Course Roadmap","docId":"appendices/weekly-roadmap","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"appendices/hardware-guide":{"id":"appendices/hardware-guide","title":"Appendix A: Hardware Guide","description":"This appendix provides a detailed guide to the hardware required to follow the hands-on portions of this book, both for the digital twin workstation and for building a physical robot.","sidebar":"tutorialSidebar"},"appendices/weekly-roadmap":{"id":"appendices/weekly-roadmap","title":"Appendix B: 13-Week Course Roadmap","description":"This appendix provides a suggested 13-week roadmap for readers following this book as part of a course or structured self-study program. Each week includes reading assignments, practical goals, and a key milestone.","sidebar":"tutorialSidebar"},"capstone/main":{"id":"capstone/main","title":"Part VI: Capstone Project - The Autonomous Humanoid Assistant","description":"This capstone project is where we bring together all the concepts, technologies, and skills developed throughout this book. The goal is to build an end-to-end Vision-Language-Action (VLA) pipeline for a humanoid robot, enabling it to act as an autonomous assistant in a simulated home or office environment.","sidebar":"tutorialSidebar"},"foundations/intro":{"id":"foundations/intro","title":"Part I: Foundations of Physical AI & Embodied Intelligence","description":"Welcome to the beginning of your journey into the fascinating world of humanoid robotics. This initial part of the book lays the essential groundwork, introducing the core concepts of Physical AI and Embodied Intelligence. Understanding these principles is crucial before we dive into the practical aspects of building and programming intelligent robots.","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Introduction: Building the Future of Physical AI","description":"Welcome to \"Physical AI & Humanoid Robotics,\" your comprehensive guide to designing, building, and programming the next generation of intelligent, embodied agents. This book will take you on a journey from the fundamental principles of robotics and AI to the cutting-edge technologies that are making autonomous humanoid robots a reality.","sidebar":"tutorialSidebar"},"module1/rclpy":{"id":"module1/rclpy","title":"Chapter 5: A Closer Look at rclpy","description":"Throughout this module, we've been using the rclpy library to write our ROS 2 nodes in Python. rclpy (ROS Client Library for Python) is the official Python client library for ROS 2. It provides a high-level, Pythonic interface to the underlying C++ libraries and the ROS 2 middleware, allowing you to build complex robotics applications with ease.","sidebar":"tutorialSidebar"},"module1/ros2-actions":{"id":"module1/ros2-actions","title":"Chapter 4: Handling Long-Running Tasks with ROS 2 Actions","description":"For tasks that take a long time to complete and need to provide feedback along the way, neither topics nor services are a perfect fit. ROS 2 provides another communication pattern called actions for exactly these scenarios. Actions are the backbone of complex robotics behaviors like navigation, manipulation, and executing multi-step sequences.","sidebar":"tutorialSidebar"},"module1/ros2-nodes":{"id":"module1/ros2-nodes","title":"Chapter 1: Understanding ROS 2 Nodes","description":"A ROS 2 system is a distributed network of processes called nodes. Each node is a fundamental unit of computation and should be responsible for a single, modular purpose (e.g., one node for controlling wheel motors, one for processing camera images, and another for planning paths). This chapter explains what nodes are and how to create and manage them.","sidebar":"tutorialSidebar"},"module1/ros2-services":{"id":"module1/ros2-services","title":"Chapter 3: Using ROS 2 Services for Request/Response","description":"While topics are great for continuous data streams, sometimes you need a direct request/response interaction between nodes. This is where services come in. This chapter will introduce you to the service communication pattern in ROS 2.","sidebar":"tutorialSidebar"},"module1/ros2-topics":{"id":"module1/ros2-topics","title":"Chapter 2: Communicating with ROS 2 Topics","description":"Nodes communicate with each other by publishing messages to topics. Topics are named buses over which nodes exchange messages. This chapter explains how to use topics to send and receive data.","sidebar":"tutorialSidebar"},"module2/gazebo-simulation":{"id":"module2/gazebo-simulation","title":"Chapter 7: Simulating the World with Gazebo","description":"With a URDF model in hand, we can bring our robot to life in a simulated environment. Gazebo is a powerful 3D robotics simulator that allows you to test your robot's design and control algorithms in a realistic virtual world before deploying them on a physical robot.","sidebar":"tutorialSidebar"},"module2/unity-rendering":{"id":"module2/unity-rendering","title":"Chapter 8: High-Fidelity Simulation with Unity","description":"While Gazebo is excellent for physics simulation, the Unity game engine offers a powerful alternative for creating high-fidelity, visually rich simulation environments. Unity is particularly strong in areas like realistic rendering, complex sensor simulation, and creating large, interactive worlds, making it an ideal choice for training and testing perception and HRI algorithms.","sidebar":"tutorialSidebar"},"module2/urdf-modeling":{"id":"module2/urdf-modeling","title":"Chapter 6: Modeling a Humanoid with URDF","description":"Before we can simulate our robot, we need a detailed digital model of it. In ROS, the standard format for describing a robot's structure is the Unified Robot Description Format (URDF). This chapter covers the essentials of creating a URDF file, from basic links and joints to more advanced concepts needed for accurate simulation.","sidebar":"tutorialSidebar"},"module3/isaac-ros":{"id":"module3/isaac-ros","title":"Chapter 10: Accelerating Robotics with Isaac ROS","description":"NVIDIA Isaac ROS is a collection of hardware-accelerated packages for ROS 2, specifically designed to leverage the power of NVIDIA GPUs and Jetson platforms. It provides high-performance, AI-accelerated capabilities for common robotics tasks, enabling developers to build and deploy complex perception and navigation pipelines more efficiently.","sidebar":"tutorialSidebar"},"module3/isaac-sim-basics":{"id":"module3/isaac-sim-basics","title":"Chapter 9: NVIDIA Isaac Sim for Advanced Simulation","description":"NVIDIA Isaac Sim is a scalable robotics simulation platform and synthetic data generation tool. Built on the NVIDIA Omniverseâ„¢ platform, it is designed to create physically accurate, photorealistic simulations that are essential for developing, testing, and training AI-based robots in a virtual environment before deploying them to the real world.","sidebar":"tutorialSidebar"},"module3/nav2-biped":{"id":"module3/nav2-biped","title":"Chapter 11: Bipedal Navigation with Nav2","description":"Navigating in complex, human-centric environments is a fundamental capability for any humanoid robot. For wheeled robots, ROS 2's Nav2 stack is the de facto standard, providing a robust and modular solution. However, adapting Nav2 for a bipedal humanoid presents unique challenges that require significant customization of its core components.","sidebar":"tutorialSidebar"},"module4/llm-planning":{"id":"module4/llm-planning","title":"Chapter 13: Cognitive Planning with Large Language Models","description":"Once a robot can perceive its environment and understand human speech, the next frontier is enabling it to reason about high-level commands and generate a sequence of actions to achieve them. This is where Large Language Models (LLMs) like GPT-4 and Claude 3 serve as a \"cognitive engine\" for the robot, translating natural language into actionable plans.","sidebar":"tutorialSidebar"},"module4/vla-pipelines":{"id":"module4/vla-pipelines","title":"Chapter 14: Building Vision-Language-Action (VLA) Pipelines","description":"We've now explored the key components of an intelligent robotics system: vision (perception), language (speech recognition and understanding), and action (robot control). The final step is to integrate these components into a cohesive Vision-Language-Action (VLA) pipeline, which is the architecture that brings everything together to create a truly interactive and intelligent robot.","sidebar":"tutorialSidebar"},"module4/whisper":{"id":"module4/whisper","title":"Chapter 12: Voice Control with OpenAI Whisper","description":"For humanoid robots to interact naturally and intuitively with humans, voice control is a crucial capability. OpenAI's Whisper is a state-of-the-art automatic speech recognition (ASR) model that can accurately transcribe human speech into text, making it an excellent foundation for building voice-controlled robotics systems.","sidebar":"tutorialSidebar"}}}}